./back-end/app.py:
from flask import Flask
from flask_cors import CORS
from models import db
from routes.quiz_routes import quiz_bp
from config import Config

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    CORS(app)
    db.init_app(app)

    app.register_blueprint(quiz_bp)

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=False)

./back-end/config.py:
import os

class Config:
    DB_USERNAME = 'system' # os.getenv('DB_USERNAME')
    DB_PASSWORD = 'test123' # os.getenv('DB_PASSWORD')
    DB_HOST = os.getenv('DB_HOST', 'localhost')
    DB_PORT = os.getenv('DB_PORT', '5432')
    DB_NAME = os.getenv('DB_NAME', 'quizdb')
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'your-secret-key'
    SQLALCHEMY_DATABASE_URI = f"postgresql://{DB_USERNAME}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
    SQLALCHEMY_TRACK_MODIFICATIONS = False

./back-end/models/quiz.py:
# models/quiz.py
from . import db
from datetime import datetime

class Subject(db.Model):
    subjectID = db.Column(db.String, primary_key=True)
    name = db.Column(db.String, nullable=False)
    description = db.Column(db.Text)
    endpoint = db.Column(db.Text)
    subheading = db.Column(db.Text)
    icon = db.Column(db.Text)
    quizzes = db.relationship('Quiz', backref='subject_ref', lazy=True)

    def to_dict(self):
        return {
            'subjectID': self.subjectID,
            'name': self.name,
            'description': self.description,
            'endpoint': self.endpoint,
            'subheading': self.subheading,
            'icon': self.icon
        }


class Quiz(db.Model):
    quizID = db.Column(db.String, primary_key=True)
    subjectID = db.Column(db.String, db.ForeignKey('subject.subjectID'), nullable=False)
    date = db.Column(db.Date, nullable=False)
    sourceFile = db.Column(db.String, nullable=False)
    questions = db.relationship('Question', backref='quiz', lazy=True)
    is_published = db.Column(db.Boolean, nullable=False)

class Question(db.Model):
    quizID = db.Column(db.String, db.ForeignKey('quiz.quizID'), primary_key=True)
    questionNumber = db.Column(db.Integer, primary_key=True)
    questionText = db.Column(db.Text, nullable=False)
    answerOptions = db.Column(db.ARRAY(db.String), nullable=False)
    correctAnswer = db.Column(db.String, nullable=False)
    correctAnswerIndex = db.Column(db.Integer, nullable=False)
    hint = db.Column(db.Text)
    explanation = db.Column(db.Text)
    sources = db.Column(db.Text)
    grade = db.Column(db.String, nullable=False)
    gradeReason = db.Column(db.Text)

    def to_dict(self):
        return {
            'quizID': self.quizID,
            'questionNumber': self.questionNumber,
            'questionText': self.questionText,
            'answerOptions': self.answerOptions,
            'correctAnswer': self.correctAnswer,
            'correctAnswerIndex': self.correctAnswerIndex,
            'hint': self.hint,
            'explanation': self.explanation,
            'sources': self.sources,
            'grade': self.grade,
            'gradeReason': self.gradeReason
        }

    def update_from_dict(self, data):
        for key, value in data.items():
            if hasattr(self, key):
                setattr(self, key, value)

    @classmethod
    def from_dict(cls, data):
        return cls(
            quizID=data.get('quizID'),
            questionNumber=data.get('questionNumber'),
            questionText=data.get('questionText'),
            answerOptions=data.get('answerOptions'),
            correctAnswer=data.get('correctAnswer'),
            correctAnswerIndex=data.get('correctAnswerIndex'),
            hint=data.get('hint'),
            explanation=data.get('explanation'),
            sources=data.get('sources'),
            grade=data.get('grade', ''),  # Provide a default value if not present
            gradeReason=data.get('gradeReason')
        )

class OriginalQuestion(db.Model):
    __tablename__ = 'original_question'
    quizID = db.Column(db.String, db.ForeignKey('quiz.quizID'), primary_key=True)
    questionNumber = db.Column(db.Integer, primary_key=True)
    questionText = db.Column(db.Text, nullable=False)
    answerOptions = db.Column(db.ARRAY(db.String), nullable=False)
    correctAnswer = db.Column(db.String, nullable=False)
    correctAnswerIndex = db.Column(db.Integer, nullable=False)
    hint = db.Column(db.Text)
    explanation = db.Column(db.Text)
    sources = db.Column(db.Text)
    ideas = db.Column(db.Text)

class User(db.Model):
    userID = db.Column(db.String, primary_key=True)
    quizAttempts = db.relationship('QuizAttempt', backref='user', lazy=True)

class QuizAttempt(db.Model):
    attemptID = db.Column(db.String, primary_key=True)
    userID = db.Column(db.String, db.ForeignKey('user.userID'), nullable=False)
    quizID = db.Column(db.String, db.ForeignKey('quiz.quizID'), nullable=False)
    date = db.Column(db.Date, nullable=False)
    score = db.Column(db.Integer)
    questionresults = db.Column(db.ARRAY(db.Integer))

class Feedback(db.Model):
    feedbackID = db.Column(db.String, primary_key=True)
    userID = db.Column(db.String, db.ForeignKey('user.userID'), nullable=False)
    quizID = db.Column(db.String, db.ForeignKey('quiz.quizID'), nullable=False)
    questionNumber = db.Column(db.Integer, nullable=False)
    feedback = db.Column(db.Text, nullable=False)
    date = db.Column(db.DateTime, nullable=False)

    # Add relationship to Question table
    question = db.relationship('Question', 
                               primaryjoin="and_(Feedback.quizID==Question.quizID, "
                                           "Feedback.questionNumber==Question.questionNumber)",
                               foreign_keys=[quizID, questionNumber],
                               backref=db.backref('feedback', lazy='dynamic'))

    def to_dict(self):
        return {
            'feedbackID': self.feedbackID,
            'userID': self.userID,
            'quizID': self.quizID,
            'feedback': self.feedback,
            'questionNumber': self.questionNumber,
            'date': self.date.isoformat(),  # Convert datetime to ISO format string
            'question': self.question.to_dict()
        }

class EditLog(db.Model):
    __tablename__ = 'edit_log'
    id = db.Column(db.Integer, primary_key=True)
    quizID = db.Column(db.String, db.ForeignKey('quiz.quizID'), nullable=False)
    questionNumber = db.Column(db.Integer, nullable=False)
    field = db.Column(db.String, nullable=False)
    oldText = db.Column(db.Text, nullable=False)
    newText = db.Column(db.Text, nullable=False)
    reason = db.Column(db.String, nullable=False)
    timestamp = db.Column(db.DateTime, nullable=False)
    user = db.Column(db.String, nullable=False)
    server_timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'quizID': self.quizID,
            'questionNumber': self.questionNumber,
            'field': self.field,
            'oldText': self.oldText,
            'newText': self.newText,
            'reason': self.reason,
            'timestamp': self.timestamp.isoformat(),
            'user': self.user,
            'server_timestamp': self.server_timestamp.isoformat()
        }

./back-end/models/__init__.py:
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

from .quiz import Quiz, Question, OriginalQuestion, User, QuizAttempt, Feedback

./back-end/routes/quiz_routes.py:
from flask import Blueprint, jsonify, request, render_template, make_response, url_for
from services.quiz_service import QuizService
from datetime import datetime
import uuid

quiz_bp = Blueprint('quiz', __name__)

def get_or_create_user_id():
    user_id = request.cookies.get('user_id')
    if not user_id:
        user_id = str(uuid.uuid4())
    return user_id

@quiz_bp.route('/api/init')
def init_page():
    print('Init page')
    subjects = QuizService.get_all_subjects()
    print([s.to_dict() for s in subjects])
    subject_data = jsonify([
        s.to_dict()
        for s in subjects  
    ])
    print(subject_data)
    user_id = get_or_create_user_id()
    response = make_response(subject_data)
    response.set_cookie('user_id', user_id, max_age=60*60*24*365)  # Cookie expires in 1 year
    return response

@quiz_bp.route('/api/subjects')
def get_subjects():
    subjects = QuizService.get_all_subjects()
    return jsonify([subject.to_dict() for subject in subjects])



./back-end/routes/__init__.py:


./back-end/services/quiz_service.py:
# services/db_service.py

from models import db
from models.quiz import Subject, Quiz, Question, User, QuizAttempt, Feedback
from sqlalchemy.orm import joinedload
from datetime import datetime, date
import uuid

class QuizService:
    @staticmethod
    def get_all_subjects():
        return Subject.query.all()

    @staticmethod
    def get_subject(subject_id):
        return Subject.query.get(subject_id)

    @staticmethod
    def get_todays_quiz(subject_id):
        today = date.today()
        return Quiz.query.filter_by(subjectID=subject_id, date=today).first()

    @staticmethod
    def get_or_create_user(user_id):
        user = User.query.get(user_id)
        if not user:
            user = User(userID=user_id)
            db.session.add(user)
            db.session.commit()
        return user

    @staticmethod
    def has_user_taken_quiz_today(user_id, subject_id):
        today = date.today()
        attempt = QuizAttempt.query.filter_by(
            userID=user_id,
            date=today
        ).join(Quiz).filter_by(subjectID=subject_id).first()
        return attempt is not None

    @staticmethod
    def record_quiz_attempt(user_id, quiz_id, question_results, total_score):
        results_array = [int(v) for k,v in question_results.items()]
        attempt = QuizAttempt(
            attemptID=str(uuid.uuid4()),
            userID=user_id,
            quizID=quiz_id,
            date=date.today(),
            score=total_score,
            questionresults=results_array
        )
        db.session.add(attempt)
        db.session.commit()

    @staticmethod
    def submit_feedback(user_id, quiz_id, question_number, feedback_text):
        feedback = Feedback(
            feedbackID=str(uuid.uuid4()),
            userID=user_id,
            quizID=quiz_id,
            questionNumber=question_number,
            feedback=feedback_text,
            date=datetime.now()
        )
        db.session.add(feedback)
        db.session.commit()

./back-end/services/__init__.py: